# POV Cam — Backend Architecture & Infrastructure

## 1. Overview

The backend is a Node.js/Express API server that handles metadata operations, session management, quota enforcement, and signed URL generation. It never handles file binary data — all file uploads and downloads flow directly between the client and Cloudflare R2.

---

## 2. System Components

### 2.1 API Server (Node/Express)

- **Runtime:** Node.js with Express
- **Deployment:** Vercel (serverless API routes)
- **Responsibilities:** Session management, quota enforcement, signed URL generation, event CRUD, rate limiting, media validation
- **Does NOT:** Handle file uploads/downloads, serve static assets, render HTML

### 2.2 Supabase Postgres

- **Role:** Primary data store for all application state
- **Connection:** Via Supabase connection string with PgBouncer in transaction mode
- **Pool size:** 20-30 connections (not 200 — PgBouncer multiplexes)
- **Tables:** events, device_sessions, media, organizers, event_organizers

### 2.3 Cloudflare R2

- **Role:** File storage for photos, thumbnails, and archives
- **Backend:** S3-compatible object storage (Cloudflare R2)
- **Buckets:** `originals`, `thumbs`, `archives`
- **Access:** All reads and writes via signed URLs generated by the API server
- **Path convention:** `{event_id}/{media_id}.{ext}`

### 2.4 Supabase Auth

- **Role:** Organizer authentication only
- **Provides:** JWT-based auth with email/password
- **Not used for:** Guest authentication (guests use device session cookies)

### 2.5 Background Job Runner

- **MVP:** Simple `setInterval` or `node-cron` jobs running in the same process as the API server
- **Stage 2+:** Separate worker process with BullMQ + Redis for job queuing
- **Jobs:** Orphan cleanup, thumbnail fallback, ZIP generation, event expiry

### 2.6 Cache Layer

- **MVP:** In-memory cache (e.g., `node-cache`) for event config (capacity limits, max guests, status)
- **Stage 2+:** Redis (Upstash serverless) for rate limiting state and event config cache
- **TTL:** 60 seconds for event config. Short enough to pick up capacity upgrades quickly, long enough to avoid hitting Postgres on every request.

> [!NOTE]
> R2 signed URLs work without a CDN layer. For higher traffic, place Cloudflare caching in front of image delivery where appropriate, but keep originals private.

---

## 3. Database Schema

### 3.1 events

```sql
CREATE TABLE events (
  id                     UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name                   TEXT NOT NULL,
  slug                   TEXT UNIQUE NOT NULL,
  max_guests             INT NOT NULL DEFAULT 100,
  max_uploads_per_guest  INT NOT NULL DEFAULT 10,
  compression_mode       TEXT NOT NULL DEFAULT 'compressed'
                           CHECK (compression_mode IN ('compressed', 'raw')),
  total_fee              INT NOT NULL DEFAULT 0,  -- total fee in minor units for `currency`
  currency               CHAR(3) NOT NULL DEFAULT 'INR',
  pin_hash               TEXT,
  status                 TEXT NOT NULL DEFAULT 'active'
                           CHECK (status IN ('draft', 'active', 'closed', 'archived', 'purged')),
  cover_image_path       TEXT,
  event_date             DATE NOT NULL,
  end_date               DATE NOT NULL,
  expires_at             TIMESTAMPTZ NOT NULL,
  created_at             TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_events_slug ON events(slug);
CREATE INDEX idx_events_status ON events(status);
CREATE INDEX idx_events_date_window ON events(event_date, end_date);
```

**Compression mode:**
- `compressed` (default): Client converts uploads to JPEG, resizes long side to max 4000px, and encodes at JPEG quality 0.8 before upload.
- `raw`: Client uploads original files without compression. Available for an additional fee.

**Fee fields:**
- `total_fee` stores money in minor units (for example, paise when `currency = 'INR'`).
- `currency` stores the ISO 4217 currency code (for example, `INR`, `USD`, `EUR`).

> [!IMPORTANT]
> `compression_mode` can only be changed before the event opens. Opening is derived from `event_date` with the configured early-open UTC buffer.

**Flexible Pricing Model (INR):**

| Component | Free Tier | Additional Cost |
|-----------|-----------|-----------------|
| Guests | First 100 | +₹200 per 100 guests |
| Images/guest | First 10 | +₹100 per 10 images, per 100 guests |
| Uncompressed | — | +₹1 per image capacity |

**Pricing Formula:**

```javascript
function calculateEventFee(guests, imagesPerGuest, isUncompressed) {
  // Guest blocks (100 guests each, first block is free)
  const guestBlocks = Math.ceil(guests / 100);
  const paidGuestBlocks = Math.max(0, guestBlocks - 1);
  const guestFee = paidGuestBlocks * 200; // ₹200 per 100 guests
  
  // Image tiers (10 images each, first tier is free)
  const imageTiers = Math.ceil(imagesPerGuest / 10);
  const paidImageTiers = Math.max(0, imageTiers - 1);
  const imageFee = paidImageTiers * 100 * guestBlocks; // ₹100 per tier per 100 guests
  
  // Uncompressed add-on
  const uncompressedFee = isUncompressed ? guests * imagesPerGuest * 1 : 0; // ₹1 per image
  
  return (guestFee + imageFee + uncompressedFee) * 100; // in minor units for configured currency
}
```

**Pricing Examples:**

| Guests | Images/Guest | Compressed | Uncompressed |
|--------|--------------|------------|--------------|
| 100    | 10           | **Free**   | ₹1,000       |
| 200    | 10           | ₹200       | ₹2,200       |
| 200    | 20           | ₹400       | ₹4,400       |
| 500    | 20           | ₹1,200     | ₹11,200      |
| 1,000  | 30           | ₹3,800     | ₹33,800      |

> [!NOTE]
> The fee is calculated and charged upfront at event creation. Changes to guests/images before the event starts recalculate and charge the difference.

### 3.2 device_sessions

```sql
CREATE TABLE device_sessions (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_id        UUID NOT NULL REFERENCES events(id),
  token_hash      TEXT NOT NULL,
  display_name    TEXT,
  is_active       BOOLEAN NOT NULL DEFAULT true,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  last_active_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_sessions_event ON device_sessions(event_id);
CREATE INDEX idx_sessions_token_hash ON device_sessions(token_hash);
CREATE INDEX idx_sessions_active ON device_sessions(event_id, is_active);
```

### 3.3 media

```sql
CREATE TABLE media (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_id          UUID NOT NULL REFERENCES events(id),
  device_session_id UUID NOT NULL REFERENCES device_sessions(id),
  storage_path      TEXT NOT NULL,
  thumb_path        TEXT,
  mime_type         TEXT NOT NULL,
  size_bytes        INT NOT NULL,
  uploader_name     TEXT,
  tags              TEXT[] NOT NULL DEFAULT '{}',
  status            TEXT NOT NULL DEFAULT 'pending'
                      CHECK (status IN ('pending', 'uploaded', 'failed', 'expired', 'hidden')),
  width             INT,
  height            INT,
  duration          INT,
  uploaded_at       TIMESTAMPTZ,
  storage_deleted_at TIMESTAMPTZ,
  storage_delete_attempts INT NOT NULL DEFAULT 0,
  storage_last_delete_error TEXT,
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_media_session ON media(device_session_id, status);
CREATE INDEX idx_media_event ON media(event_id, status);
CREATE INDEX idx_media_event_uploader ON media(event_id, uploader_name);
CREATE INDEX idx_media_pending_cleanup ON media(status, created_at)
  WHERE status = 'pending';
CREATE INDEX idx_media_storage_cleanup ON media(status, storage_deleted_at, created_at)
  WHERE status = 'expired' AND storage_deleted_at IS NULL;
```

The `idx_media_pending_cleanup` partial index is specifically for the orphan cleanup job — it only indexes rows where `status = 'pending'`, keeping the index small and fast.

### 3.4 gallery facet tables

Precomputed facet tables support fast organizer filter-option loading:

```sql
CREATE TABLE event_uploader_facets (
  event_id       UUID NOT NULL REFERENCES events(id) ON DELETE CASCADE,
  uploader_name  TEXT NOT NULL,
  media_count    INT NOT NULL DEFAULT 0 CHECK (media_count >= 0),
  updated_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (event_id, uploader_name)
);

CREATE TABLE event_tag_facets (
  event_id       UUID NOT NULL REFERENCES events(id) ON DELETE CASCADE,
  tag            TEXT NOT NULL,
  media_count    INT NOT NULL DEFAULT 0 CHECK (media_count >= 0),
  updated_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (event_id, tag)
);
```

- Incremental updates happen on upload completion and cleanup transitions.
- Daily `data-cleanup` cron also rebuilds these tables to reconcile drift.
- Organizer filter options are fetched from `/api/organizer/events/:id/gallery/facets` with `limit <= 500`.

### 3.5 organizers

```sql
CREATE TABLE organizers (
  id         UUID PRIMARY KEY,  -- matches Supabase Auth user ID
  email      TEXT UNIQUE NOT NULL,
  name       TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```

### 3.6 event_organizers

```sql
CREATE TABLE event_organizers (
  event_id     UUID NOT NULL REFERENCES events(id),
  organizer_id UUID NOT NULL REFERENCES organizers(id),
  role         TEXT NOT NULL DEFAULT 'owner'
                 CHECK (role IN ('owner', 'collaborator')),
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (event_id, organizer_id)
);
```

---

## 4. API Endpoints

### 4.1 Guest Endpoints

All guest endpoints authenticate via the `device_session_token` cookie. No JWT required.

| Method | Path                  | Purpose                                | Auth            |
| ------ | --------------------- | -------------------------------------- | --------------- |
| POST   | /api/lookup-event     | Lookup event before join               | Event slug      |
| POST   | /api/join             | Join event, create session, set cookie | Event slug + optional PIN |
| GET    | /api/my-session       | Validate cookie, return session info   | Cookie          |
| POST   | /api/create-upload    | Reserve quota slot, get signed URL     | Cookie          |
| POST   | /api/complete-upload  | Mark upload as complete                | Cookie          |
| GET    | /api/my-uploads       | List guest's own uploads               | Cookie          |
| PATCH  | /api/my-session       | Update display name                    | Cookie          |

### 4.2 Organizer Endpoints

Organizer endpoints support either organizer session cookie auth or Supabase bearer auth.

| Method | Path                                        | Purpose                          |
| ------ | ------------------------------------------- | -------------------------------- |
| POST   | /api/organizer/auth/session                 | Exchange Supabase bearer for API session cookie |
| GET    | /api/organizer/auth/session                 | Fetch current organizer session/identity |
| DELETE | /api/organizer/auth/session                 | Revoke organizer API session cookie |
| POST   | /api/organizer/events                       | Create event                     |
| GET    | /api/organizer/events                       | List organizer's events          |
| GET    | /api/organizer/events/:id                   | Event detail + stats             |
| PATCH  | /api/organizer/events/:id                   | Update event settings            |
| POST   | /api/organizer/events/:id/close             | Stop accepting uploads           |
| POST   | /api/organizer/events/:id/archive           | Archive event                    |
| GET    | /api/organizer/events/:id/gallery           | Paginated media list             |
| GET    | /api/organizer/events/:id/gallery/stats     | Upload stats and breakdown       |
| POST   | /api/organizer/events/:id/media/:mid/hide   | Hide a photo                     |
| POST   | /api/organizer/events/:id/media/:mid/unhide | Unhide a photo                   |
| POST   | /api/organizer/events/:id/media/bulk-hide   | Bulk hide photos                 |
| GET    | /api/organizer/events/:id/media/:mid/download-url | Signed URL for original    |
| POST   | /api/organizer/events/:id/media/download-urls | Batch signed URLs (max 100) |
| POST   | /api/organizer/events/:id/download-all      | Trigger async ZIP job            |
| GET    | /api/organizer/jobs/:job_id                 | Poll job status                  |
| GET    | /api/organizer/events/:id/guests            | List guest sessions              |
| POST   | /api/organizer/events/:id/guests/:sid/deactivate | Deactivate a session       |
| POST   | /api/organizer/events/:id/capacity          | Update event capacity (payment if increased)     |

### 4.3 Webhook Endpoints

| Method | Path                      | Purpose                              |
| ------ | ------------------------- | ------------------------------------ |
| POST   | /api/webhooks/payment     | Payment provider callback (currently scaffolded, returns 501) |

---

## 5. Middleware Stack

Every request passes through a middleware chain. Order matters.

```
Request
  → CORS
  → Cookie parser
  → Rate limiter (per IP + per device token)
  → Route handler
    → Auth middleware (cookie-based for guest; cookie or bearer for organizer)
    → Validation middleware (request body schema)
    → Controller logic
    → Response
```

### 5.1 Rate Limiting

| Scope         | Limit              | Window  | Applied To             |
| ------------- | ------------------- | ------- | ---------------------- |
| Per IP        | 100 requests        | 1 min   | All endpoints          |
| Per device    | 60 requests         | 1 min   | Guest endpoints        |
| Per IP (join) | 10 requests         | 5 min   | POST /api/join only    |
| Per IP (upload)| 20 requests        | 1 min   | POST /api/create-upload|

**MVP implementation:** `express-rate-limit` with in-memory store. Sufficient for a single-instance deployment.

**Stage 2+:** Redis-backed rate limiter (`rate-limit-redis`) for multi-instance deployments.

### 5.2 Media Validation

Applied at `POST /api/create-upload` before any DB operations:

- **File type:**  
  - `compressed` mode: `image/jpeg`, `image/png`, `image/webp`  
  - `raw` mode: `image/jpeg`, `image/png`, `image/webp`, `image/heic`, and RAW families (`.cr2`, `.nef`, `.arw`, `.dng`, `.orf`, `.rw2`)
- **File size:**  
  - `compressed` mode: 5MB max  
  - `raw` mode: 15MB for JPEG/PNG/WebP/HEIC, 25MB for RAW families  
  Checked against the declared `file_size` in the request body and re-verified at `complete-upload` using storage object metadata.
- **File count:** Implicit via the atomic quota check in the DB query.

### 5.3 Upload Completion Verification

Applied at `POST /api/complete-upload` before marking status as `uploaded`:

- Validate that the media row belongs to the current device session and is currently `pending`.
- Fetch object metadata from storage for `storage_path` (existence + non-zero size + content-type/extension sanity check).
- Only after successful storage verification, set `media.status = 'uploaded'` and `uploaded_at = now()`.
- If verification fails, return an error and keep row `pending` for retry or cleanup.

### 5.4 Event Config Cache

To avoid querying the `events` table on every request (especially during 200+ concurrent uploads), event configuration is cached in memory.

```javascript
// Cached fields: max_uploads_per_guest, max_guests, compression_mode, status, expires_at
// Key: event_id
// TTL: 60 seconds
```

Cache is invalidated on:
- Capacity upgrade (webhook handler clears cache for that event)
- Event status change (close/archive endpoint clears cache)
- Event settings update (max_guests change via PATCH endpoint clears cache)
- TTL expiry

> [!IMPORTANT]
> All event update operations must invalidate the cache. Use a wrapper function for consistency.

---

### 5.5 Storage Operation Retries

All storage operations (signed URL generation, head checks, deletions) should use retry with exponential backoff:

```javascript
async function withRetry<T>(fn: () => Promise<T>, maxRetries = 3): Promise<T> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (err) {
      if (attempt === maxRetries) throw err;
      await sleep(Math.pow(2, attempt) * 100); // 200ms, 400ms, 800ms
    }
  }
}
```

---

## 6. Signed URL Flow

This is the central pattern of the entire system. The API server generates time-limited, scoped URLs that allow the client to interact with Cloudflare R2 directly.

### 6.1 Upload Signed URLs

Generated at `POST /api/create-upload`:

```ts
const uploadUrl = await createSignedStorageUploadUrl('originals', `${eventId}/${mediaId}.${ext}`);
```

Properties:
- **Scoped to a single file path.** Cannot be reused for another file.
- **TTL:** Configurable via `SIGNED_URL_TTL_SECONDS` (default 15 minutes).
- **Write-only.** Cannot be used to read or delete.

### 6.2 Download Signed URLs

Generated at `GET /api/my-uploads`, `GET .../gallery`, and `GET .../download-url`:

```ts
const downloadUrl = await createSignedStorageObjectUrl('thumbs', `${eventId}/${mediaId}.jpg`);
```

Properties:
- **Scoped to a single file.**
- **Configurable expiry.** Controlled by `SIGNED_URL_TTL_SECONDS`.
- **Read-only.** Cannot be used to write or delete.

### 6.3 Why Signed URLs (Not RLS)

Signed URLs are a better fit here because:

- Guests don't have Supabase Auth JWTs (they're cookie-session users, not Supabase Auth users).
- Signed URLs are simpler to reason about and debug.
- They allow fine-grained, time-limited access without complex RLS policy chains.
- The API server remains the single authority on who can access what.

---

## 7. Background Jobs

### 7.1 Orphan Cleanup

**Schedule:** Every 5-10 minutes.

**Logic:**

```sql
UPDATE media
SET status = 'expired'
WHERE status = 'pending'
  AND created_at < now() - INTERVAL '30 minutes'
RETURNING id, storage_path, thumb_path;
```

This handles cases where `create-upload` succeeded (quota slot reserved, `pending` row created) but the client never completed the upload (network failure, browser closed, etc.). Setting status to `expired` frees the quota slot for the guest.

**Mandatory:** For each `expired` row where `storage_deleted_at IS NULL`, delete the corresponding files from storage and track the result:

```javascript
for (const row of rowsNeedingDeletion) {
  try {
    await storage.deleteObject('originals', row.storage_path);
    if (row.thumb_path) {
      await storage.deleteObject('thumbs', row.thumb_path);
    }

    await db.query(
      `UPDATE media
       SET storage_deleted_at = now(),
           storage_last_delete_error = NULL
       WHERE id = $1`,
      [row.id]
    );
  } catch (err) {
    await db.query(
      `UPDATE media
       SET storage_delete_attempts = storage_delete_attempts + 1,
           storage_last_delete_error = $2
       WHERE id = $1`,
      [row.id, String(err).slice(0, 1000)]
    );
  }
}
```

Rows with `storage_deleted_at IS NULL` are retried by subsequent cleanup runs. Alert if `storage_delete_attempts` exceeds a threshold.

### 7.2 Thumbnail Fallback

**Trigger:** After `complete-upload` verification succeeds, a job checks if a thumbnail exists at `thumbs/{event_id}/{media_id}.jpg`.

**Logic:**
1. Attempt to fetch metadata for the thumb path from Cloudflare R2.
2. If it doesn't exist (client-side generation failed):
   a. Download the original from `originals/{event_id}/{media_id}.ext`.
   b. Resize to 400px wide, JPEG quality 0.7 using `sharp` library.
   c. Upload the generated thumbnail to `thumbs/{event_id}/{media_id}.jpg`.

**MVP:** Fire-and-forget after responding to the client (non-blocking):

```javascript
res.json({ success: true, media_id });

// Non-blocking thumbnail check
setImmediate(async () => {
  try {
    const thumbExists = await storage.headObject('thumbs', thumbPath);
    if (!thumbExists) {
      await generateAndUploadThumbnail(originalPath, thumbPath);
    }
  } catch (err) {
    logger.error('Thumbnail fallback failed', { mediaId, err });
  }
});
```

A periodic backup job (every 5 min) also checks for `uploaded` media missing thumbnails.

### 7.3 RAW Thumbnail Extraction (New)

**Trigger:** `uploaded` media with `mime_type` indicating RAW format (e.g., `image/x-canon-cr2`) and `thumb_path` containing "placeholder".

**Logic (Stage 2+ Worker, or Serverless Function):**
1. Download original RAW file (25MB+).
2. Extract embedded JPEG preview using `libraw` / `exiftool` / `sharp` (if supported).
3. Resize extracted preview to 400px width (JPEG 0.6).
4. Overwrite the placeholder at `thumb_path`.
5. Update `media` status if needed.

**Note:** This is resource-intensive. For MVP, we might rely on a slightly longer-running Node.js job or an edge function with higher memory limits.

**Stage 2+:** Queued via BullMQ and processed by a worker.

### 7.3 ZIP Generation

**Trigger:** `POST /api/organizer/events/:id/download-all`

**Logic:**
1. Create a job record in a `jobs` table (status: `processing`).
2. Query all `uploaded` media for the event (excluding `hidden` if requested).
3. Stream originals from Cloudflare R2.
4. Pipe through `archiver` library to create a ZIP.
5. Upload the ZIP to a temporary storage bucket.
6. Generate a signed download URL for the ZIP.
7. Update job record: status `complete`, attach download URL.
8. ZIP expires after download URL expires. Cleanup job deletes stale ZIPs.

### 7.4 Event Status + Retention Cron

- Event status reconciliation runs every 12 hours at `00:00` and `12:00` UTC.
- Data cleanup runs daily at `01:00` UTC.
- Event status is driven by `event_date` and `end_date` with UTC buffers (open 13h early, close 13h late).
- Internal endpoints used by Supabase cron:
  - `POST /api/internal/event-status-sync`
  - `POST /api/internal/data-cleanup`

---

## 8. Concurrent Upload Handling

The most performance-critical path. At 200+ concurrent guests, this must be correct and fast.

### The Problem

If a guest has 3 upload slots remaining and fires off 5 concurrent `create-upload` requests, a naive implementation could allow all 5 through (each reads `count = 12`, each sees `12 < 15`).

### The Solution

Atomic reservation at `create-upload` using a single SQL query:

```sql
WITH quota_check AS (
  SELECT COUNT(*) as current_count
  FROM media
  WHERE device_session_id = $1
    AND status IN ('pending', 'uploaded')
)
INSERT INTO media (id, event_id, device_session_id, status, mime_type,
                   size_bytes, storage_path, thumb_path, uploader_name, tags)
SELECT gen_random_uuid(), $2, $1, 'pending', $3, $4, $5, $6, $8, $9::text[]
FROM quota_check
WHERE quota_check.current_count < $7
RETURNING id;
```

**Why this works:**
- The `INSERT ... SELECT ... WHERE` is atomic within a single transaction.
- `pending` rows count toward the quota, so each reservation reduces available slots.
- Postgres serializes concurrent inserts for the same `device_session_id` naturally via row-level locking on the `media` table.
- If the insert returns no rows, the quota is full.

**Cleanup:** `pending` rows that never transition to `uploaded` are cleaned up by the orphan cleanup job, which frees the quota slot.

---

## 9. Storage Architecture

### 9.1 Bucket Structure

```
originals/                     (private bucket)
  {event_id}/
    {media_id}.jpg
    {media_id}.png
    {media_id}.cr2
    ...

thumbs/                        (private bucket)
  {event_id}/
    {media_id}.jpg             (always JPEG regardless of original format)
    ...
```

### 9.2 Why This Structure

- **Event ID as top-level directory:** Enables bulk operations. When an event is archived and purged, delete everything under `originals/{event_id}/` and `thumbs/{event_id}/` in one operation.
- **Media ID as filename:** Prevents collisions, removes user-controlled input from paths (security), keeps things predictable.
- **Extension from validated MIME type:** Not from the user-provided filename.

### 9.3 Storage Costs (Estimates)

Assumptions: 200 guests, 15 uploads each = 3,000 photos per event. Average compressed size: 2MB original, 50KB thumbnail.

| Item        | Per Event | 10 Events/Month |
| ----------- | --------- | --------------- |
| Originals   | 6 GB      | 60 GB           |
| Thumbnails  | 150 MB    | 1.5 GB          |
| Total       | ~6.15 GB  | ~61.5 GB        |

Cloudflare R2 offers a generous free tier with zero egress fees; monitor object count, storage volume, and operation-class usage as scale grows.

At 10 events/month, storage cost remains low on R2 free tier limits. Past that, costs are primarily object storage volume/operations rather than egress to guests.

---

## 10. Deployment Strategy

### Stage 1 — MVP / Validation (0-50 events)

| Component            | Platform       | Cost          |
| -------------------- | -------------- | ------------- |
| Guest + Organizer frontend | Vercel Pro     | $20/month     |
| API backend          | Vercel         | depends on function usage |
| Database             | Supabase Pro   | $25/month     |
| Storage              | Cloudflare R2  | free tier / usage based |
| Cache + Rate Limit   | In-memory      | $0            |
| Background Jobs      | Same process   | $0            |
| **Total**            |                | **~$50-52/month** |

Serverless API deployment on Vercel. Scheduled tasks are invoked via Supabase pg_cron calling protected internal API endpoints.

### Stage 2 — Early Traction (50-500 events)

| Component            | Platform       | Cost          |
| -------------------- | -------------- | ------------- |
| Frontend             | Vercel Pro     | $20/month     |
| API backend          | Vercel (scaled functions) | usage based |
| Database             | Supabase Pro   | $25 + overage |
| Storage              | Cloudflare R2  | usage based |
| Redis (cache + rate limit) | Upstash   | $10/month     |
| Background Jobs      | Dedicated worker/service | usage based |
| CDN for thumbnails   | Cloudflare     | Free tier     |
| **Total**            |                | **~$80-120/month** |

Separate worker process for background jobs. Redis for rate limiting across multiple API instances. Cloudflare CDN in front of thumbnail serving.

### Stage 3 — Scale (500+ concurrent events)

| Component            | Platform       | Notes         |
| -------------------- | -------------- | ------------- |
| Frontend             | Vercel Pro/Enterprise | Scale as needed |
| API backend          | Vercel / ECS / Fly.io | Auto-scaling |
| Database             | Supabase Pro or dedicated Postgres | Connection pooling critical |
| Storage              | Cloudflare R2 or S3 + CDN | Evaluate cost |
| Job Queue            | BullMQ + Redis | Dedicated queue |
| CDN                  | Cloudflare Pro | Caching layer |

At this stage, evaluate whether R2 pricing/perf still fits or whether to shift to S3 + CDN. Keep storage behind an adapter to preserve migration flexibility.

---

## 11. Security Architecture

### 11.1 No Public Storage Access

All storage buckets (`originals`, `thumbs`, `archives`) are private. No file is accessible without a signed URL generated by the API server. There are no public object URLs in the system.

### 11.2 Signed URLs Are Scoped

- Upload URLs: write-only, single path, TTL controlled by `SIGNED_URL_TTL_SECONDS` (default 15 minutes).
- Download URLs: read-only, single path, same configurable TTL.
- No delete URLs are ever generated for guests.

### 11.3 Server-Side Quota Enforcement

All limits are enforced server-side. The client UI shows limits for UX, but the server is the authority. A malicious client cannot bypass quotas by modifying JavaScript.

### 11.4 Session Security

- Device tokens are cryptographically random (32 bytes, hex-encoded).
- Only the hash is stored in the database.
- Tokens are transmitted only via HttpOnly cookies — never in URLs, query params, or request bodies.
- SameSite=Strict prevents CSRF.

### 11.5 Organizer Auth

- Supabase JWTs are still the identity source.
- Web organizer app uses API session cookies (`organizer_session_token`) for API calls.
- Organizer endpoints accept bearer auth as a fallback for non-browser clients.
- Event ownership/collaborator checks are still enforced on protected organizer routes.
- JWT expiry is short (1 hour). Refresh tokens handle session continuity.

### 11.6 Abuse Protection Layers

| Layer                    | Protection Against                    | When Applied       |
| ------------------------ | ------------------------------------- | ------------------ |
| Rate limit per IP        | DDoS, brute force                     | All endpoints      |
| Rate limit per device    | Single device spamming                | Guest endpoints    |
| Upload quota per device  | Cost abuse via excessive uploads      | create-upload      |
| Guest limit per event    | Unlimited session creation            | join               |
| File size limit          | Oversized uploads driving up costs    | create-upload      |
| File type validation     | Malicious file uploads                | create-upload      |
| Event PIN (optional)     | Unauthorized access if link leaks     | join               |
| Signed URL expiry        | Stale URLs being reused               | All storage access |

---

## 12. Data Retention & Cleanup

| Event Status | Retention                                          |
| ------------ | -------------------------------------------------- |
| active       | Indefinite (until closed or expires)               |
| closed       | 30 days, then auto-archived                        |
| archived     | 30 days, then status moves to `purged` and storage is deleted |
| purged       | Storage files deleted; event retained only as minimal record/metadata |

Organizer is notified (email) before storage purge, giving them a window to download if they haven't already.

---

## 13. Monitoring & Observability (Stage 2+)

### Key Metrics to Track

- `create-upload` latency (p50, p95, p99) — this is the hottest endpoint
- Upload completion rate (% of `pending` that reach `uploaded` vs. `expired`)
- Active sessions per event
- Storage consumption per event
- Rate limit hits per endpoint
- Background job queue depth and processing time

### Logging

- Structured JSON logs from Express.
- Log every `create-upload` and `complete-upload` with event_id, session_id, media_id.
- Log every rate limit hit.
- Log every background job execution with duration and outcome.

### Alerting

- Alert if `create-upload` p95 latency exceeds 500ms.
- Alert if orphan cleanup finds more than 100 `pending` rows (may indicate a systemic issue).
- Alert if storage consumption for a single event exceeds a threshold.
